<html lang="en">
<head>
<meta charset="UTF-8">
<title>Blimp Map Viewer - Stargate Teleport</title>

<style>
body { margin:0; background:#010103; overflow:hidden; font-family:'Segoe UI',sans-serif; }

#ui{
    position:absolute;
    top:20px;
    left:20px;
    color:#00ffff;
    text-transform:uppercase;
    letter-spacing:2px;
    text-shadow:0 0 10px #00ffff;
    z-index:10;
}

#message{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    color:#00ffff;
    font-size:24px;
    text-shadow:0 0 20px #00ffff;
    opacity:0;
    transition:opacity 0.5s;
    pointer-events:none;
    z-index:20;
}

.controls{
    display:flex;
    gap:10px;
    margin-top:10px;
}

button{
    background:rgba(0,255,255,0.1);
    border:1px solid #00ffff;
    color:#00ffff;
    padding:10px;
    cursor:pointer;
    font-weight:bold;
}

button:hover{ background:rgba(0,255,255,0.4); }

#loading{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    color:#00ffff;
    z-index:15;
}
</style>
</head>
<body>

<div id="ui">
    Blimp Map Viewer
    <div class="controls">
        <button id="viewBtn">Drone View</button>
    </div>
</div>
<div id="message"></div>
<div id="loading">Loading map...</div>

<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.160.0",
    "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const scene = new THREE.Scene();
scene.background = null;

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 1, 15000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(600,600,600);

let mapObjects = new THREE.Group();
scene.add(mapObjects);

let blimpMesh;
let viewMode='follow';
let velocity=new THREE.Vector3(0,0,1);
let wanderAngle=0;
let currentTarget=new THREE.Vector3();
const cruiseAlt=130;
const keys={Left:false,Right:false};

const ambientLight=new THREE.AmbientLight(0xffffff,0.8);
scene.add(ambientLight);

const sunLight=new THREE.DirectionalLight(0xffffff,1);
sunLight.position.set(500,1000,500);
scene.add(sunLight);

/* --- MATERIALS --- */
const buildingMaterial=new THREE.MeshStandardMaterial({
    color:0x111122,
    transparent:true,
    opacity:0.6
});

const roadMaterial=new THREE.MeshStandardMaterial({
    color:0x00f3ff,
    emissive:0x0066ff,
    emissiveIntensity:3
});

const blimpMaterial=new THREE.MeshStandardMaterial({
    color:0x111111,
    metalness:0.9,
    roughness:0.2
});
/* ----------------- */

// Map locations
const locations = {
    london: { lat: 51.5074, lon: -0.1278, name: 'London' },
    newyork: { lat: 40.7128, lon: -74.0060, name: 'newyork' }
};

let currentLocation = 'london';
let starGate;
let messageTimeout;

window.addEventListener('keydown',(e)=>{
    if(e.key==='ArrowLeft') keys.Left=true;
    if(e.key==='ArrowRight') keys.Right=true;
});
window.addEventListener('keyup',(e)=>{
    if(e.key==='ArrowLeft') keys.Left=false;
    if(e.key==='ArrowRight') keys.Right=false;
});

function project(lon,lat,centerLon,centerLat){
    return{
        x:(lon-centerLon)*111320*Math.cos(centerLat*Math.PI/180),
        z:(lat-centerLat)*110540*-1
    };
}

function showMessage(text){
    const msg = document.getElementById('message');
    msg.textContent = text;
    msg.style.opacity = '1';
    
    if(messageTimeout) clearTimeout(messageTimeout);
    messageTimeout = setTimeout(() => {
        msg.style.opacity = '0';
    }, 3000);
}

async function loadMap(lat, lon, locationName){
    document.getElementById('loading').style.display='block';
    document.getElementById('loading').textContent = `Loading ${locationName}...`;

    // Clear existing map objects
    while(mapObjects.children.length>0){
        const obj=mapObjects.children[0];
        if(obj.geometry) obj.geometry.dispose();
        mapObjects.remove(obj);
    }

    // Remove old stargate if exists
    if(starGate) {
        scene.remove(starGate);
        starGate = null;
    }

    // Load the appropriate GeoJSON
    const url = `https://mapsmania.github.io/neon/data/${locationName.toLowerCase()}.geojson`;
    
    try {
        const response = await fetch(url);
        const data = await response.json();

        data.features.filter(f => f.geometry && f.geometry.type === 'Polygon')
            .forEach((f,i) => {
                const coords = f.geometry.coordinates[0];
                const points = coords.map(c=>{
                    const pos=project(c[0],c[1],lon,lat);
                    return new THREE.Vector3(pos.x,0,pos.z);
                });
                if(points.length < 2) return;

                const shape = new THREE.Shape(points.map(p=>new THREE.Vector2(p.x,p.z)));
                const height = 60;

                const geometry = new THREE.ExtrudeGeometry(shape, {depth:height, bevelEnabled:false});
                const mesh = new THREE.Mesh(geometry, buildingMaterial.clone());
                mesh.rotation.x=Math.PI/2;
                mesh.position.y=height;

                mesh.add(new THREE.LineSegments(
                    new THREE.EdgesGeometry(geometry),
                    new THREE.LineBasicMaterial({color:0x0088ff})
                ));

                mapObjects.add(mesh);
            });

        // Position blimp at appropriate location
        if(blimpMesh) {
            blimpMesh.position.set(0, cruiseAlt, 0);
        }

        // Create stargate at edge of map
        starGate = createStarGate(800, 800, 80, 0x00ff00);
        
        // Add a second stargate for return trip in New York
        if(locationName === 'New York') {
            starGate = createStarGate(-800, -800, 80, 0xff00ff);
        }

        document.getElementById('loading').style.display='none';
        showMessage(`Arrived in ${locationName}`);
        
    } catch (error) {
        console.error('Error loading map:', error);
        document.getElementById('loading').style.display='none';
        showMessage('Error loading map');
    }
}

function createBlimp(){
    if(blimpMesh) return;

    blimpMesh=new THREE.Group();

    const hullGeom=new THREE.SphereGeometry(12,32,32);
    hullGeom.scale(0.8,0.8,1.8);

    const hull=new THREE.Mesh(hullGeom,blimpMaterial);
    hull.add(new THREE.LineSegments(
        new THREE.EdgesGeometry(hullGeom),
        new THREE.LineBasicMaterial({color:0xffff00})
    ));
    blimpMesh.add(hull);

    const gondola=new THREE.Mesh(
        new THREE.BoxGeometry(6,3,12),
        blimpMaterial
    );
    gondola.position.y=-8;
    blimpMesh.add(gondola);

    scene.add(blimpMesh);
}

// ---- STAR GATE FUNCTION ----
function createStarGate(x, z, radius=50, color=0x00ff00){
    const gateGroup = new THREE.Group();

    // store data
    gateGroup.userData.radius = radius;
    gateGroup.userData.color = color;

    // Main circle - glowing effect
    const geometry = new THREE.CircleGeometry(radius, 64);
    const material = new THREE.MeshBasicMaterial({
        color: color,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3
    });
    const circle = new THREE.Mesh(geometry, material);
    gateGroup.add(circle);

    // Inner ring
    const ringGeom = new THREE.TorusGeometry(radius-5, 3, 32, 100);
    const ringMat = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 2
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.rotation.z = Math.PI / 2;
    gateGroup.add(ring);

    // Outer ring
    const outerRingGeom = new THREE.TorusGeometry(radius+5, 2, 32, 100);
    const outerRingMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: color,
        emissiveIntensity: 1
    });
    const outerRing = new THREE.Mesh(outerRingGeom, outerRingMat);
    outerRing.rotation.x = Math.PI / 2;
    outerRing.rotation.z = Math.PI / 2;
    gateGroup.add(outerRing);

    // Add particles
    const particleCount = 100;
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    
    for(let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2;
        const r = radius + 10 + Math.sin(i * 10) * 5;
        particlePositions[i*3] = Math.cos(angle) * r;
        particlePositions[i*3+1] = (Math.random() - 0.5) * 20;
        particlePositions[i*3+2] = Math.sin(angle) * r;
    }
    
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particleMat = new THREE.PointsMaterial({ color: color, size: 2 });
    const particles = new THREE.Points(particleGeom, particleMat);
    gateGroup.add(particles);

    gateGroup.position.set(x, cruiseAlt, z);
    scene.add(gateGroup);

    return gateGroup;
}

function checkStarGate(blimpPos, gate){
    const dx = blimpPos.x - gate.position.x;
    const dz = blimpPos.z - gate.position.z;
    const distance = Math.sqrt(dx*dx + dz*dz);

    return distance < gate.userData.radius + 20;
}

async function teleportToNewYork() {
    showMessage('Wormhole activated! Teleporting to New York...');
    
    // Visual effect - fade out
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = '#00ffff';
    overlay.style.opacity = '0';
    overlay.style.transition = 'opacity 1s';
    overlay.style.pointerEvents = 'none';
    overlay.style.zIndex = '100';
    document.body.appendChild(overlay);
    
    // Fade to white
    setTimeout(() => {
        overlay.style.opacity = '1';
    }, 100);
    
    // Load New York after fade
    setTimeout(async () => {
        await loadMap(locations.newyork.lat, locations.newyork.lon, locations.newyork.name);
        currentLocation = 'newyork';
        
        // Position blimp near the return stargate
        if(blimpMesh) {
            blimpMesh.position.set(800, cruiseAlt, 800);
        }
        
        // Fade back in
        overlay.style.opacity = '0';
        
        // Remove overlay
        setTimeout(() => {
            document.body.removeChild(overlay);
        }, 1000);
    }, 1000);
}

function animate(){
    requestAnimationFrame(animate);

    if(starGate) {
        starGate.lookAt(blimpMesh.position);
        
        // Rotate the rings
        starGate.children.forEach(child => {
            if(child.geometry && child.geometry.type === 'TorusGeometry') {
                child.rotation.y += 0.01;
            }
        });
        
        // Check for teleport
        if(checkStarGate(blimpMesh.position, starGate)) {
            if(currentLocation === 'london') {
                teleportToNewYork();
            }
        }
    }

    if(keys.Left) wanderAngle+=0.025;
    if(keys.Right) wanderAngle-=0.025;

    velocity.lerp(new THREE.Vector3(Math.sin(wanderAngle),0,Math.cos(wanderAngle)),0.05);

    if(blimpMesh){
        blimpMesh.position.add(velocity.clone().multiplyScalar(1.5));
        blimpMesh.lookAt(blimpMesh.position.clone().add(velocity));
        blimpMesh.position.y = cruiseAlt + Math.sin(Date.now()*0.001)*8;

        if(viewMode==='follow'){
            const camOffset = velocity.clone().normalize().multiplyScalar(-250);
            const camPos = blimpMesh.position.clone().add(camOffset);
            camPos.y = cruiseAlt + 120;
            camera.position.lerp(camPos, 0.05);
            camera.lookAt(blimpMesh.position);
        } else {
            camera.position.lerp(currentTarget, 0.01);
            if(camera.position.distanceTo(currentTarget)<50){
                currentTarget.set(
                    camera.position.x + (Math.random()-0.5)*800,
                    400 + Math.random()*400,
                    camera.position.z + (Math.random()-0.5)*800
                );
            }
            camera.lookAt(blimpMesh.position);
        }
    }

    renderer.render(scene, camera);
}

document.getElementById('viewBtn').addEventListener('click',(e)=>{
    if(viewMode === 'follow'){
        viewMode='drone';
        currentTarget.copy(camera.position);
        e.target.innerText = 'Follow Blimp';
    } else {
        viewMode='follow';
        e.target.innerText = 'Drone View';
    }
});

// Initialize
createBlimp();
loadMap(locations.london.lat, locations.london.lon, locations.london.name);

animate();
</script>
</body>
</html>
