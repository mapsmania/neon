<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Neon Pilot - Manhattan Airship</title>
    <style>
        body { margin: 0; background: #010103; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #ui { 
            position: absolute; top: 20px; left: 20px; 
            color: #00ffff; pointer-events: none; 
            text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff;
            display: flex; flex-direction: column; gap: 10px;
        }
        .controls { display: flex; gap: 10px; pointer-events: auto; }
        .hint { font-size: 0.8rem; color: #ffff00; margin-top: 5px; opacity: 0.8; }
        button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff; color: #00ffff; padding: 10px;
            cursor: pointer; text-transform: uppercase; font-weight: bold;
            transition: 0.2s;
        }
        button:hover { background: rgba(0, 255, 255, 0.4); }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff; font-size: 1.2rem; text-align: center;
            background: rgba(2, 2, 5, 0.8); padding: 20px;
        }
    </style>
</head>
<body>
    <div id="ui">
        Aerial Surveillance Grid
        <div class="controls">
            <button id="viewBtn">Follow Blimp</button>
            <button id="nycBtn">Jump to Manhattan</button>
        </div>
        <div class="hint">Use LEFT / RIGHT ARROWS to Steer</div>
    </div>
    <div id="loading">Initializing Satellite Link...</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 15000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        camera.position.set(600, 600, 600);

        let viewMode = 'drone', droneActive = false;
        let currentTarget = new THREE.Vector3(200, 300, 200);
        let buildings = [];
        let mapObjects = new THREE.Group();
        scene.add(mapObjects);

        const raycaster = new THREE.Raycaster();
        let blimpMesh, blimpActive = false;
        
        // --- FLIGHT PHYSICS & CONTROLS ---
        let velocity = new THREE.Vector3(0, 0, 1);
        let wanderAngle = 0;
        const cruiseAlt = 130;
        const keys = { Left: false, Right: false };

        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x00f3ff, emissive: 0x0066ff, emissiveIntensity: 3 });
        const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x111122, transparent: true, opacity: 0.6 });
        const blimpMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
        const neonYellow = new THREE.LineBasicMaterial({ color: 0xffff00 });

        // Event Listeners for Piloting
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.Left = true;
            if (e.key === 'ArrowRight') keys.Right = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.Left = false;
            if (e.key === 'ArrowRight') keys.Right = false;
        });

        function project(lon, lat, centerLon, centerLat) {
            const x = (lon - centerLon) * 111320 * Math.cos(centerLat * Math.PI / 180);
            const z = (lat - centerLat) * 110540 * -1;
            return { x, z };
        }

        async function loadMap(lat, lon) {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            while(mapObjects.children.length > 0) {
                const obj = mapObjects.children[0];
                if(obj.geometry) obj.geometry.dispose();
                mapObjects.remove(obj);
            }
            buildings = [];
            blimpActive = false;
            
            try {
                const offset = 0.008; 
                const bbox = `${lat - offset},${lon - offset},${lat + offset},${lon + offset}`;
                const query = `[out:json][timeout:25];(way["highway"](${bbox});way["building"](${bbox}););out body;>;out skel qt;`;
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                const data = await response.json();
                const nodes = {};
                data.elements.filter(e => e.type === 'node').forEach(n => nodes[n.id] = { lat: n.lat, lon: n.lon });
                const ways = data.elements.filter(e => e.type === 'way');
                const centerNode = { lat, lon };

                ways.forEach(way => {
                    const points = way.nodes.map(id => nodes[id]).filter(n => n);
                    if (points.length < 2) return;
                    const v3Points = points.map(n => {
                        const pos = project(n.lon, n.lat, centerNode.lon, centerNode.lat);
                        return new THREE.Vector3(pos.x, 0, pos.z);
                    });

                    if (way.tags.building) {
                        const shape = new THREE.Shape(v3Points.map(p => new THREE.Vector2(p.x, p.z)));
                        const height = (way.tags["building:levels"] || 5) * 12; 
                        const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
                        const mesh = new THREE.Mesh(geometry, buildingMaterial);
                        mesh.rotation.x = Math.PI / 2;
                        mesh.position.y = height; 
                        mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x0088ff })));
                        mapObjects.add(mesh);
                        buildings.push(mesh);
                    } else {
                        const curve = new THREE.CatmullRomCurve3(v3Points);
                        mapObjects.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 1, 8, false), roadMaterial));
                    }
                });

                if (!blimpMesh) {
                    const blimpGroup = new THREE.Group();
                    const blimpGeom = new THREE.SphereGeometry(12, 32, 32);
                    blimpGeom.scale(0.8, 0.8, 1.8); // Z is long axis
                    const hull = new THREE.Mesh(blimpGeom, blimpMaterial);
                    hull.add(new THREE.LineSegments(new THREE.EdgesGeometry(blimpGeom), neonYellow));
                    blimpGroup.add(hull);
                    const gondolaGeom = new THREE.BoxGeometry(6, 3, 12);
                    const gondola = new THREE.Mesh(gondolaGeom, blimpMaterial);
                    gondola.position.y = -8;
                    gondola.add(new THREE.LineSegments(new THREE.EdgesGeometry(gondolaGeom), neonYellow));
                    blimpGroup.add(gondola);
                    blimpMesh = blimpGroup;
                    scene.add(blimpMesh);
                }
                blimpMesh.position.set(0, cruiseAlt, 0);
                blimpActive = true;
                droneActive = true;
                loadingEl.style.display = 'none';
            } catch (err) { loadingEl.innerText = "Re-syncing..."; }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (blimpActive) {
                // 1. Input-driven Steering
                let turnSpeed = 0.025;
                if (keys.Left) wanderAngle += turnSpeed;
                if (keys.Right) wanderAngle -= turnSpeed;

                const targetVelocity = new THREE.Vector3(
                    Math.sin(wanderAngle), 
                    0, 
                    Math.cos(wanderAngle)
                );
                
                // Lerp velocity for "heavy" momentum
                velocity.lerp(targetVelocity, 0.05);

                // 2. Automated Safety Nudge (Avoidance)
                raycaster.set(blimpMesh.position, velocity.clone().normalize());
                const obstacles = raycaster.intersectObjects(buildings);
                if (obstacles.length > 0 && obstacles[0].distance < 100) {
                    const avoidance = new THREE.Vector3(-velocity.z, 0, velocity.x).multiplyScalar(0.02);
                    velocity.add(avoidance);
                }

                // Apply movement
                blimpMesh.position.add(velocity.clone().multiplyScalar(1.5));

                // 3. Dynamic Banking & LookAt
                // Calculate bank based on turn input
                let bankTarget = 0;
                if (keys.Left) bankTarget = 0.3;
                if (keys.Right) bankTarget = -0.3;
                blimpMesh.rotation.z = THREE.MathUtils.lerp(blimpMesh.rotation.z, bankTarget, 0.05);

                // Ensure the blimp faces its velocity
                const lookTarget = blimpMesh.position.clone().add(velocity);
                blimpMesh.lookAt(lookTarget);

                // Vertical Bobbing
                blimpMesh.position.y = cruiseAlt + Math.sin(Date.now() * 0.001) * 8;

                if (viewMode === 'car') {
                    const camOffset = velocity.clone().normalize().multiplyScalar(-220);
                    camera.position.lerp(new THREE.Vector3(blimpMesh.position.x + camOffset.x, cruiseAlt + 100, blimpMesh.position.z + camOffset.z), 0.05);
                    camera.lookAt(blimpMesh.position);
                }
            }

            if (viewMode === 'drone' && droneActive) {
                camera.position.lerp(currentTarget, 0.005);
                camera.lookAt(0,0,0);
                if (camera.position.distanceTo(currentTarget) < 100) {
                    currentTarget.set((Math.random()-0.5)*1500, 600, (Math.random()-0.5)*1500);
                }
            }
            renderer.render(scene, camera);
        }

        document.getElementById('viewBtn').addEventListener('click', () => {
            viewMode = (viewMode === 'drone') ? 'car' : 'drone';
            document.getElementById('viewBtn').innerText = (viewMode === 'drone') ? "Follow Blimp" : "Drone View";
        });

        document.getElementById('nycBtn').addEventListener('click', () => loadMap(40.7588, -73.9851));
        navigator.geolocation.getCurrentPosition(p => loadMap(p.coords.latitude, p.coords.longitude), () => loadMap(51.507, -0.127));
        animate();
    </script>
</body>
</html>
