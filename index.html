<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Neon Neighborhood - Manhattan Edition</title>
    <style>
        body { margin: 0; background: #020205; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #ui { 
            position: absolute; top: 20px; left: 20px; 
            color: #00ffff; pointer-events: none; 
            text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff;
            display: flex; flex-direction: column; gap: 10px;
        }
        .controls { display: flex; gap: 10px; pointer-events: auto; }
        button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff; color: #00ffff; padding: 10px;
            cursor: pointer; text-transform: uppercase; font-weight: bold;
            transition: 0.2s;
        }
        button:hover { background: rgba(0, 255, 255, 0.4); }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff; font-size: 1.2rem; text-align: center;
            background: rgba(2, 2, 5, 0.8); padding: 20px;
        }
    </style>
</head>
<body>
    <div id="ui">
        Localized 3D Network
        <div class="controls">
            <button id="viewBtn">Follow Runner</button>
            <button id="nycBtn">Jump to Manhattan</button>
        </div>
    </div>
    <div id="loading">Initializng System...</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        camera.position.set(400, 400, 400);

        let viewMode = 'drone', droneActive = false;
        let currentTarget = new THREE.Vector3(200, 200, 200);
        let buildings = [];
        let mapObjects = new THREE.Group(); // Container for easy clearing
        scene.add(mapObjects);

        const raycaster = new THREE.Raycaster();
        let carMesh, carActive = false;
        let carDir = new THREE.Vector3(0, 0, 1);
        let carSpeed = 2.0;
        let turnCooldown = 0;

        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x00f3ff, emissive: 0x0066ff, emissiveIntensity: 4 });
        const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x111122, transparent: true, opacity: 0.7 });
        const carMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 1, roughness: 0.2 });
        const neonYellow = new THREE.LineBasicMaterial({ color: 0xffff00 });

        function project(lon, lat, centerLon, centerLat) {
            const x = (lon - centerLon) * 111320 * Math.cos(centerLat * Math.PI / 180);
            const z = (lat - centerLat) * 110540 * -1;
            return { x, z };
        }

        async function loadMap(lat, lon) {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.innerText = "Reconfiguring Grid...";

            // 1. Clear existing data
            while(mapObjects.children.length > 0) {
                const obj = mapObjects.children[0];
                if(obj.geometry) obj.geometry.dispose();
                mapObjects.remove(obj);
            }
            buildings = [];
            carActive = false;

            const offset = 0.006; // Manhattan likes a slightly larger crop
            const bbox = `${lat - offset},${lon - offset},${lat + offset},${lon + offset}`;
            const query = `[out:json][timeout:25];(way["highway"](${bbox});way["building"](${bbox}););out body;>;out skel qt;`;
            
            try {
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                const data = await response.json();
                const nodes = {};
                data.elements.filter(e => e.type === 'node').forEach(n => nodes[n.id] = { lat: n.lat, lon: n.lon });

                const ways = data.elements.filter(e => e.type === 'way');
                const centerNode = { lat, lon };

                ways.forEach(way => {
                    const points = way.nodes.map(id => nodes[id]).filter(n => n);
                    if (points.length < 2) return;
                    
                    const v3Points = points.map(n => {
                        const pos = project(n.lon, n.lat, centerNode.lon, centerNode.lat);
                        return new THREE.Vector3(pos.x, 0, pos.z);
                    });

                    if (way.tags.building) {
                        const shape = new THREE.Shape(v3Points.map(p => new THREE.Vector2(p.x, p.z)));
                        const height = (way.tags["building:levels"] || 5) * 6;
                        const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
                        const mesh = new THREE.Mesh(geometry, buildingMaterial);
                        mesh.rotation.x = Math.PI / 2;
                        mesh.position.y = height; 
                        mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x0088ff })));
                        mapObjects.add(mesh);
                        buildings.push(mesh);
                    } else {
                        const curve = new THREE.CatmullRomCurve3(v3Points);
                        const radius = (way.tags.highway === 'primary') ? 1.5 : 0.8;
                        mapObjects.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 20, radius, 8, false), roadMaterial));
                    }
                });

                // --- Setup the Car at (0,0,0) ---
                if (!carMesh) {
                    const carGeom = new THREE.CapsuleGeometry(2, 4, 4, 16);
                    carGeom.rotateX(Math.PI / 2);
                    carMesh = new THREE.Mesh(carGeom, carMaterial);
                    carMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(carGeom), neonYellow));
                    carMesh.add(new THREE.Mesh(new THREE.TorusGeometry(2.1, 0.1, 8, 32), new THREE.MeshBasicMaterial({ color: 0xffff00 })));
                    scene.add(carMesh);
                }
                carMesh.position.set(0, 2.1, 0);
                carActive = true;
                droneActive = true;
                loadingEl.style.display = 'none';
            } catch (err) { loadingEl.innerText = "Connection lost to Overpass API."; }
        }

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const grid = new THREE.GridHelper(5000, 100, 0x111122, 0x111122);
        grid.position.y = -0.2;
        scene.add(grid);

        function animate() {
            requestAnimationFrame(animate);

            if (carActive) {
                carMesh.position.add(carDir.clone().multiplyScalar(carSpeed));
                turnCooldown--;
                
                raycaster.set(carMesh.position, carDir);
                const intersections = raycaster.intersectObjects(buildings);

                if ((intersections.length > 0 && intersections[0].distance < 35 && turnCooldown < 0) || 
                    carMesh.position.length() > 800) {
                    
                    const randTurn = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
                    carDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), randTurn);
                    carDir.x = Math.round(carDir.x);
                    carDir.z = Math.round(carDir.z);
                    carMesh.lookAt(carMesh.position.clone().add(carDir));
                    turnCooldown = 30; 
                }

                if (viewMode === 'car') {
                    const camDir = carDir.clone().normalize().multiplyScalar(-85);
                    camera.position.lerp(new THREE.Vector3(carMesh.position.x + camDir.x, 45, carMesh.position.z + camDir.z), 0.1);
                    camera.lookAt(carMesh.position.x, 15, carMesh.position.z);
                }
            }

            if (viewMode === 'drone' && droneActive) {
                camera.position.lerp(currentTarget, 0.005);
                camera.lookAt(0,0,0);
                if (camera.position.distanceTo(currentTarget) < 50) {
                    currentTarget.set((Math.random()-0.5)*1200, 400, (Math.random()-0.5)*1200);
                }
            }
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        document.getElementById('viewBtn').addEventListener('click', () => {
            viewMode = (viewMode === 'drone') ? 'car' : 'drone';
            document.getElementById('viewBtn').innerText = (viewMode === 'drone') ? "Follow Runner" : "Drone View";
        });

        document.getElementById('nycBtn').addEventListener('click', () => {
            loadMap(40.7588, -73.9851); // Times Square, NYC
        });

        // Start with user location
        navigator.geolocation.getCurrentPosition(
            p => loadMap(p.coords.latitude, p.coords.longitude), 
            () => loadMap(51.507, -0.127)
        );
        animate();
    </script>
</body>
</html>
