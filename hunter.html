<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Blimp Map Viewer - 10 Gates</title>

<style>
body { margin:0; background:#010103; overflow:hidden; font-family:'Segoe UI',sans-serif; }

#ui{
    position:absolute;
    top:20px;
    left:20px;
    color:#00ffff;
    text-transform:uppercase;
    letter-spacing:2px;
    text-shadow:0 0 10px #00ffff;
}

#loading{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    color:#00ffff;
}
</style>
</head>
<body>

<div id="ui">Blimp Map Viewer - 10 Star Gates</div>
<div id="loading">Loading map...</div>

<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.160.0",
    "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const scene = new THREE.Scene();
scene.background = null;

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 1, 15000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(600,600,600);

let mapObjects = new THREE.Group();
scene.add(mapObjects);

let blimpMesh;
let velocity = new THREE.Vector3(0,0,1);
let wanderAngle = 0;

let roadsLoaded = false;
let parksLoaded = false;    
let treesLoaded = false;    
let skyLoaded = false; 
let groundLoaded = false;

let mapMinX = Infinity;
let mapMaxX = -Infinity;
let mapMinZ = Infinity;
let mapMaxZ = -Infinity;    

const cruiseAlt = 130;
const MIN_ALTITUDE = 50;
const MAX_ALTITUDE = 250;
const ALTITUDE_SPEED = 1.2;

const keys = {Left:false, Right:false, Up:false, Down:false};
let starGates = [];

const ambientLight = new THREE.AmbientLight(0xffffff,0.8);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff,1);
sunLight.position.set(500,1000,500);
scene.add(sunLight);

const buildingMaterial = new THREE.MeshStandardMaterial({
    color:0x111122,
    transparent:true,
    opacity:0.6
});

const blimpMaterial = new THREE.MeshStandardMaterial({
    color:0x111111,
    metalness:0.9,
    roughness:0.2
});

window.addEventListener('keydown',(e)=>{
    if(e.key==='ArrowLeft') keys.Left=true;
    if(e.key==='ArrowRight') keys.Right=true;
    if(e.key==='ArrowUp') keys.Up=true;
    if(e.key==='ArrowDown') keys.Down=true;
});

window.addEventListener('keyup',(e)=>{
    if(e.key==='ArrowLeft') keys.Left=false;
    if(e.key==='ArrowRight') keys.Right=false;
    if(e.key==='ArrowUp') keys.Up=false;
    if(e.key==='ArrowDown') keys.Down=false;
});

function project(lon,lat,centerLon,centerLat){
    return{
        x:(lon-centerLon)*111320*Math.cos(centerLat*Math.PI/180),
        z:(lat-centerLat)*110540*-1
    };
}

async function loadMap(lat,lon){
    document.getElementById('loading').style.display='block';

    const response = await fetch('https://mapsmania.github.io/neon/data/london.geojson');
    const data = await response.json();

    data.features.filter(f => f.geometry && f.geometry.type === 'Polygon')
        .forEach((f,i) => {
            const coords = f.geometry.coordinates[0];
            const points = coords.map(c=>{
                const pos = project(c[0],c[1],lon,lat);

// Track bounds
mapMinX = Math.min(mapMinX, pos.x);
mapMaxX = Math.max(mapMaxX, pos.x);
mapMinZ = Math.min(mapMinZ, pos.z);
mapMaxZ = Math.max(mapMaxZ, pos.z);

return new THREE.Vector3(pos.x,0,pos.z);
            });
            if(points.length < 2) return;

            const shape = new THREE.Shape(points.map(p=>new THREE.Vector2(p.x,p.z)));
            const height = 60; 
            const geometry = new THREE.ExtrudeGeometry(shape, {depth:height, bevelEnabled:false});
            const mesh = new THREE.Mesh(geometry, buildingMaterial.clone());
            mesh.userData.type = "building";
            mesh.rotation.x=Math.PI/2;
            mesh.position.y=height;
            mesh.add(new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                new THREE.LineBasicMaterial({color:0x0088ff})
            ));
            mapObjects.add(mesh);
        });

    createBlimp();
    blimpMesh.position.set(0, cruiseAlt, 0);

    for(let i=0; i<8; i++) {

    const rx = THREE.MathUtils.lerp(mapMinX, mapMaxX, Math.random());
    const rz = THREE.MathUtils.lerp(mapMinZ, mapMaxZ, Math.random());
        const ry = 80 + Math.random() * 120;
        const gate = createStarGate(rx, rz, ry, 60);
        starGates.push(gate);
    }

    document.getElementById('loading').style.display='none';
}

function createBlimp(){
    if(blimpMesh) return;
    blimpMesh=new THREE.Group();

    const hullGeom=new THREE.SphereGeometry(12,32,32);
    hullGeom.scale(0.8,0.8,1.8);
    const hull=new THREE.Mesh(hullGeom,blimpMaterial);
    hull.add(new THREE.LineSegments(
        new THREE.EdgesGeometry(hullGeom),
        new THREE.LineBasicMaterial({color:0xffff00})
    ));
    blimpMesh.add(hull);

    const gondola=new THREE.Mesh(new THREE.BoxGeometry(6,3,12), blimpMaterial);
    gondola.position.y=-8;
    blimpMesh.add(gondola);

    scene.add(blimpMesh);
}

function createStarGate(x, z, y, radius=50){
    const gateGroup = new THREE.Group();
    gateGroup.userData.radius = radius;
    gateGroup.userData.cleared = false; // <-- ADD THIS

    const geometry = new THREE.CircleGeometry(radius, 64);
    const material = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.4
    });
    const circle = new THREE.Mesh(geometry, material);
    gateGroup.add(circle);

    const ringGeom = new THREE.RingGeometry(radius*0.9, radius, 64);
    const ringMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff00, 
        side: THREE.DoubleSide 
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    gateGroup.add(ring);

    gateGroup.position.set(x, y, z);
    gateGroup.rotation.y = Math.random() * Math.PI;
    
    scene.add(gateGroup);
    return gateGroup;
}
    
function checkStarGate(blimpPos, gate){
    const dist = blimpPos.distanceTo(gate.position);
    return dist < gate.userData.radius;
}

function animate(){
    requestAnimationFrame(animate);

    if(keys.Left) wanderAngle+=0.025;
    if(keys.Right) wanderAngle-=0.025;

    velocity.lerp(new THREE.Vector3(Math.sin(wanderAngle),0,Math.cos(wanderAngle)),0.05);

    if(blimpMesh){

        // Forward movement
        blimpMesh.position.add(velocity.clone().multiplyScalar(4));

        // Altitude controls
        if(keys.Up) blimpMesh.position.y += ALTITUDE_SPEED;
        if(keys.Down) blimpMesh.position.y -= ALTITUDE_SPEED;

        // Clamp altitude
        blimpMesh.position.y = THREE.MathUtils.clamp(
            blimpMesh.position.y,
            MIN_ALTITUDE,
            MAX_ALTITUDE
        );

        // Subtle hover
        blimpMesh.position.y += Math.sin(Date.now()*0.001) * 0.15;

        blimpMesh.lookAt(blimpMesh.position.clone().add(velocity));

        // Camera follow
        const camOffset = velocity.clone().normalize().multiplyScalar(-250);
        const camPos = blimpMesh.position.clone().add(camOffset);
        camPos.y = blimpMesh.position.y + 120;
        camera.position.lerp(camPos, 0.05);
        camera.lookAt(blimpMesh.position);

        

        
// Gate collision
starGates.forEach((gate, index) => {
    if (!gate.userData.cleared && checkStarGate(blimpMesh.position, gate)) {
        
        console.log(`Gate ${index + 1} cleared!`);
        gate.userData.cleared = true;

        // Visual feedback: Turn gate GREEN (0x00ff00)
        gate.children.forEach(child => {
            child.material.color.setHex(0x00ff00);
            child.material.opacity = 0.8; 
        });

        // DATA TRIGGERING
        // This switch handles specific gates. 
        // If a gate index isn't listed here, it still turns green but loads nothing.
        switch(index) {
            case 0: 
                loadRoads(51.5074, -0.1278); 
                break;
            case 1: 
                loadPark(51.5074, -0.1278); 
                break;
            case 2: 
                loadTrees(51.5074, -0.1278); 
                break;
            case 3: 
                loadDataSky();    // The starry horizon
                break;
            case 4:
                console.log("Gate 5: Texturing buildings...");
                const newBuildingMat = createBuildingMaterial();

                mapObjects.children.forEach(obj => {
                if (obj.userData.type === "building") {
                obj.material = newBuildingMat;
                }
                });
                break;
            case 5:
                createGroundPlane();
                break;
            case 6:
                createRain()
                break;
             
            
            // Gates 8-10 will just turn green and log to console for now
        }
    }
});    }

    renderer.render(scene, camera);
}

loadMap(51.5074, -0.1278);


async function loadRoads(lat, lon) {
    if (roadsLoaded) return;
    roadsLoaded = true;
    console.log("Loading roads data...");

    const response = await fetch('https://mapsmania.github.io/neon/data/london.geojson');
    const data = await response.json();

    const roadMaterial = new THREE.LineBasicMaterial({ 

    color:0x00f3ff,

     });    

    data.features.forEach(f => {
        if (f.geometry && f.geometry.type === 'LineString') {
            const points = f.geometry.coordinates.map(c => {
                const pos = project(c[0], c[1], lon, lat);
                return new THREE.Vector3(pos.x, 2, pos.z); // Slightly above ground
            });

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, roadMaterial);
            mapObjects.add(line);
        }
    });
    console.log("Roads loaded.");
}    

async function loadPark(lat, lon){

    console.log("Loading parks data...");

    const response = await fetch('https://mapsmania.github.io/neon/data/parks.geojson');
    const data = await response.json();

    data.features.forEach(f => {

        if(!f.geometry) return;

        // ---- POLYGON ----
        if(f.geometry.type === "Polygon"){

            const coords = f.geometry.coordinates[0];

            const points = coords.map(c => {
                const pos = project(c[0], c[1], lon, lat);
                return new THREE.Vector2(pos.x, pos.z);
            });

            if(points.length < 3) return;

            const shape = new THREE.Shape(points);

            const geometry = new THREE.ShapeGeometry(shape);

            const material = new THREE.MeshBasicMaterial({
                color: 0x00aa44,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geometry, material);

            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y = 2;

            mapObjects.add(mesh);
        }

        // ---- MULTIPOLYGON ----
        if(f.geometry.type === "MultiPolygon"){

            f.geometry.coordinates.forEach(poly => {

                const coords = poly[0];

                const points = coords.map(c => {
                    const pos = project(c[0], c[1], lon, lat);
                    return new THREE.Vector2(pos.x, pos.z);
                });

                if(points.length < 3) return;

                const shape = new THREE.Shape(points);
                const geometry = new THREE.ShapeGeometry(shape);

                const material = new THREE.MeshBasicMaterial({
                    color: 0x00aa44,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);

                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = 2;

                mapObjects.add(mesh);
            });
        }

    });

    console.log("Parks loaded.");
}


async function loadTrees(lat, lon) {
    if (treesLoaded) return;
    treesLoaded = true;
    
    console.log("Planting trees from Overpass data...");
    
    // 1. Fetch your NEW tree geojson file
    // Replace 'trees.geojson' with your actual filename or URL
    const response = await fetch('https://mapsmania.github.io/neon/data/trees.geojson'); 
    const data = await response.json();

    // 2. Filter for Point geometries (matches your Overpass format)
    const treePoints = data.features.filter(f => f.geometry && f.geometry.type === 'Point');
    
    if (treePoints.length === 0) {
        console.warn("No tree points found in the GeoJSON!");
        return;
    }

    // 3. Create the Tree Geometry (Low-Poly Trunk + Canopy)
    // We combine a cylinder and a sphere for a better look
    const trunkGeom = new THREE.CylinderGeometry(0.5, 0.5, 12, 6);
    const canopyGeom = new THREE.SphereGeometry(3, 6, 6);
    canopyGeom.translate(0, 4, 0); // Move canopy to top of trunk
    
    const treeGeometry = trunkGeom; // Simplified for this example
    // To use both, you'd usually merge them, but let's stick to a Cone for speed:
    const simpleTreeGeom = new THREE.ConeGeometry(2, 8, 5); 
    const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });

    // 4. Create the InstancedMesh
    const iMesh = new THREE.InstancedMesh(simpleTreeGeom, treeMaterial, treePoints.length);
    const dummy = new THREE.Object3D();

    treePoints.forEach((f, i) => {
    const coords = f.geometry.coordinates;
    const pos = project(coords[0], coords[1], lon, lat);

    // Increase the base scale multiplier to 3.0
    const s = (0.6 + Math.random() * 1.2) * 3.0; 
    dummy.scale.set(s, s, s);

    // IMPORTANT: If you make trees taller, 
    // you must raise their Y position so they don't sink into the ground.
    // If the trunk is 12 units high, set Y to 6.
    dummy.position.set(pos.x, 6, pos.z); 

    dummy.updateMatrix();
    iMesh.setMatrixAt(i, dummy.matrix);
});
    iMesh.instanceMatrix.needsUpdate = true;
    mapObjects.add(iMesh);
    console.log(`${treePoints.length} trees planted!`);
} 

    function loadDataSky() {
    if (skyLoaded) return;
    skyLoaded = true;
    console.log("Initializing data sky...");

    const starCount = 10000;
    const starGeometry = new THREE.BufferGeometry();
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);

    const radius = 8000; // Keep it far beyond the play area

    for (let i = 0; i < starCount; i++) {
    const theta = 2 * Math.PI * Math.random();
    // Use Math.random() * 0.5 * Math.PI to restrict phi to the upper hemisphere
    const phi = Math.random() * (Math.PI / 2); 
    
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.cos(phi); // This will now always be positive
    const z = radius * Math.sin(phi) * Math.sin(theta);

    starPositions[i * 3] = x;
    starPositions[i * 3 + 1] = y;
    starPositions[i * 3 + 2] = z;
    
    const mixedColor = new THREE.Color();
    
    // HSL: Hue = 0 (doesn't matter if Sat is 0), Saturation = 0 (grayscale)
    // Lightness = 0.3 to 1.0 (varying from dim grey to bright white)
    const brightness = 0.3 + Math.random() * 0.7;
    mixedColor.setHSL(0, 0, brightness);

    starColors[i * 3]     = mixedColor.r;
    starColors[i * 3 + 1] = mixedColor.g;
    starColors[i * 3 + 2] = mixedColor.b;
}

    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

    const starMaterial = new THREE.PointsMaterial({
        size: 4,
        vertexColors: true, // Use the colors we generated above
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: false // Stars stay same size regardless of distance
    });

    const starField = new THREE.Points(starGeometry, starMaterial);
    scene.add(starField);
}


function createBuildingMaterial() {
    return new THREE.ShaderMaterial({
        uniforms: {
            baseColor: { value: new THREE.Color(0x050510) },
            windowColor: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                // Calculate position in the world to keep windows stable
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vWorldPosition;
            uniform vec3 baseColor;
            uniform vec3 windowColor;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                // Use X and Z for horizontal, Y for vertical
                // Adjust these numbers (4.0, 8.0) to change window size
                vec2 grid = vec2(vWorldPosition.x + vWorldPosition.z, vWorldPosition.y) * vec2(0.2, 0.15);
                
                vec2 cell = floor(grid);
                vec2 fracts = fract(grid);

                // Create the window pane shape
                // step(0.3...) creates the "frame" (the dark space between windows)
                float window = step(0.3, fracts.x) * step(0.3, fracts.y) * step(fracts.x, 0.7) * step(fracts.y, 0.8);

                // Stability: Use the cell position to pick a random light state
                float chance = hash(cell);
                float isLit = step(0.7, chance); // 30% of windows are lit

                // Only show windows on the vertical sides of buildings
                // (Prevents windows from appearing on the roofs)
                float sideMask = step(0.1, abs(sin(vWorldPosition.y * 0.01))); 

                vec3 finalColor = mix(baseColor, windowColor, window * isLit);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `
    });
}    


function createGroundPlane() {

    if (groundLoaded) return;
    groundLoaded = true;

    const width = mapMaxX - mapMinX + 2000;
    const depth = mapMaxZ - mapMinZ + 2000;

    const geometry = new THREE.PlaneGeometry(width, depth);

    const material = new THREE.MeshStandardMaterial({
        color: 0x020205,
        roughness: 0.9,
        metalness: 0.1
    });

    const ground = new THREE.Mesh(geometry, material);
    ground.rotation.x = -Math.PI / 2;

    // Center it on map
    ground.position.set(
        (mapMinX + mapMaxX) / 2,
        0,
        (mapMinZ + mapMaxZ) / 2
    );

    scene.add(ground);
}

function createRain() {
    const rainCount = 3000;
    const rainGeometry = new THREE.BufferGeometry();
    const rainPositions = new Float32Array(rainCount * 3);
    const rainVelocities = [];
    
    // Create a circular texture with gradient for raindrops
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, 32, 32);
    
    // Draw a soft circular drop
    ctx.beginPath();
    ctx.arc(16, 16, 8, 0, Math.PI * 2);
    
    // Create radial gradient for soft edge
    const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 8);
    gradient.addColorStop(0, 'rgba(180, 220, 255, 1)');
    gradient.addColorStop(0.6, 'rgba(140, 180, 255, 0.8)');
    gradient.addColorStop(1, 'rgba(100, 140, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // Add a small highlight
    ctx.beginPath();
    ctx.arc(12, 12, 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.fill();
    
    const rainTexture = new THREE.CanvasTexture(canvas);
    
    for (let i = 0; i < rainCount; i++) {
        rainPositions[i*3] = (Math.random() - 0.5) * 3000;
        rainPositions[i*3+1] = Math.random() * 500;
        rainPositions[i*3+2] = (Math.random() - 0.5) * 3000;
        
        rainVelocities.push({
            y: -8 - Math.random() * 8
        });
    }
    
    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
    
    // Use PointsMaterial with circular texture
    const rainMaterial = new THREE.PointsMaterial({
        color: 0xaaccff,
        size: 12,
        map: rainTexture,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
    });
    
    const rain = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rain);
    
    // Simple animation without splashes
    function updateRain() {
        const positions = rain.geometry.attributes.position.array;
        
        // Update rain
        for (let i = 0; i < rainCount; i++) {
            positions[i*3+1] += rainVelocities[i].y;
            
            // Reset rain when it hits ground
            if (positions[i*3+1] < 0) {
                positions[i*3] = (Math.random() - 0.5) * 3000;
                positions[i*3+1] = 500;
                positions[i*3+2] = (Math.random() - 0.5) * 3000;
            }
        }
        
        rain.geometry.attributes.position.needsUpdate = true;
        
        requestAnimationFrame(updateRain);
    }
    
    updateRain();
    console.log("Rain started with circular drops");
}
    
animate();

</script>
</body>
</html>